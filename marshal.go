package zserio

import (
	"bytes"
	"fmt"

	"github.com/icza/bitio"
)

// Marshal accepts a zserio type generated by go-zserio and returns a byte
// array which represents a zserio stream. On error, it will return an empty
// slice.
func Marshal(m Marshaler) ([]byte, error) {
	var buf bytes.Buffer
	w := bitio.NewCountWriter(&buf)

	if err := m.MarshalZserio(w); err != nil {
		return nil, fmt.Errorf("marshal: %w", err)
	}

	if err := w.Close(); err != nil {
		return nil, fmt.Errorf("flush buffer: %w", err)
	}

	return buf.Bytes(), nil
}

// Unmarshal accepts a zserio byte stream and a type and returns an error if it
// happens during unmarshaling of the byte stream.
func Unmarshal(b []byte, m Unmarshaler) error {
	r := bitio.NewCountReader(bytes.NewReader(b))
	if err := m.UnmarshalZserio(r); err != nil {
		return fmt.Errorf("unmarshal: %w", err)
	}

	return nil
}

// Code generated by go-zserio. DO NOT EDIT.

package types

import (
	"errors"
	"github.com/icza/bitio"
	zserio "github.com/woven-planet/go-zserio/interface"
	"github.com/woven-planet/go-zserio/ztype"
)

type ValueWrapper struct {
	Parameter   int32
	Value       int32
	OtherValue  int8
	EnumValue   Color
	Description string
}

func (v *ValueWrapper) Clone() zserio.ZserioType {
	clone := &ValueWrapper{}
	*clone = *v
	return clone
}

func (v *ValueWrapper) LoadDefaultValues() error {

	if err := v.EnumValue.LoadDefaultValues(); err != nil {
		return err
	}

	return nil
}

// MarshalZserio implements the zserio.Marshaler interface.
func (v *ValueWrapper) MarshalZserio(w *bitio.CountWriter) error {
	var err error

	if err = ztype.WriteInt32(w, v.Value); err != nil {
		return err
	}

	if err = ztype.WriteInt8(w, v.OtherValue); err != nil {
		return err
	}

	if v.Parameter == 7 {
		if err := ztype.AlignWriter(w, 16); err != nil {
			return err
		}
		if err = v.EnumValue.MarshalZserio(w); err != nil {
			return err
		}
	}

	if err := ztype.AlignWriter(w, 8); err != nil {
		return err
	}
	if err = ztype.WriteString(w, v.Description); err != nil {
		return err
	}
	_ = err // to avoid "declared but not used" warning
	return nil
}

// UnmarshalZserio implements the zserio.Unmarshaler interface.
func (v *ValueWrapper) UnmarshalZserio(r *bitio.CountReader) error {
	var err error

	if tempValue, err := ztype.ReadInt32(r); err == nil {
		v.Value = (int32)(tempValue)
	} else {
		return err
	}

	if tempValue, err := ztype.ReadInt8(r); err == nil {
		v.OtherValue = (int8)(tempValue)
	} else {
		return err
	}

	if v.Parameter == 7 {
		ztype.AlignReader(r, 16)

		if err = v.EnumValue.UnmarshalZserio(r); err != nil {
			return err
		}
	}

	ztype.AlignReader(r, 8)
	if tempValue, err := ztype.ReadString(r); err == nil {
		v.Description = (string)(tempValue)
	} else {
		return err
	}
	_ = err // to avoid "declared but not used" warning
	return nil
}

func (v *ValueWrapper) GetValue() int32 {
	retVal := v.Value + v.Parameter
	return int32(retVal)
}

// ZserioBitSize implements the zserio.Marshaler interface.
func (v *ValueWrapper) ZserioBitSize(bitPosition int) (int, error) {
	endBitPosition := bitPosition
	endBitPosition += 32
	endBitPosition += 8
	if v.Parameter == 7 {
		endBitPosition += ztype.CountAlignBits(endBitPosition, 16)

		if delta, err := v.EnumValue.ZserioBitSize(endBitPosition); err != nil {
			return 0, err
		} else {
			endBitPosition += delta
		}
	}
	endBitPosition += ztype.CountAlignBits(endBitPosition, 8)

	if delta, err := ztype.BitSizeOfString(v.Description); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}
	return endBitPosition - bitPosition, nil
}

func (v *ValueWrapper) ZserioCreatePackingContext(contextNode *zserio.PackingContextNode) error {

	fieldValueNode := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldValueNode)
	// The field is not a marshalable type, therefore create use a delta context.
	fieldValueNode.Context = &ztype.DeltaContext[int32]{}

	fieldOtherValueNode := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldOtherValueNode)
	// The field is not a marshalable type, therefore create use a delta context.
	fieldOtherValueNode.Context = &ztype.DeltaContext[int8]{}

	fieldEnumValueNode := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldEnumValueNode)
	var fieldEnumValuePtr *Color
	if err := fieldEnumValuePtr.ZserioCreatePackingContext(fieldEnumValueNode); err != nil {
		return err
	}

	fieldDescriptionNode := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldDescriptionNode)

	return nil
}

func (v *ValueWrapper) ZserioInitPackingContext(contextNode *zserio.PackingContextNode) error {
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldValueContext, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		fieldValueContext.Init(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, int32(v.Value))
	}

	if fieldOtherValueContext, ok := childrenNodes[1].Context.(*ztype.DeltaContext[int8]); !ok {
		return errors.New("unknown context type")
	} else {
		fieldOtherValueContext.Init(&ztype.BitFieldArrayTraits[int8]{NumBits: uint8(8)}, int8(v.OtherValue))
	}

	if v.Parameter == 7 {

		if err := v.EnumValue.ZserioInitPackingContext(childrenNodes[2]); err != nil {
			return err
		}
	}

	return nil
}

func (v *ValueWrapper) UnmarshalZserioPacked(contextNode *zserio.PackingContextNode, r *bitio.CountReader) error {
	var err error
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldValueContext, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		if tempValue, err := fieldValueContext.Read(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, r); err == nil {
			v.Value = (int32)(tempValue)
		} else {
			return err
		}
	}

	if fieldOtherValueContext, ok := childrenNodes[1].Context.(*ztype.DeltaContext[int8]); !ok {
		return errors.New("unknown context type")
	} else {
		if tempValue, err := fieldOtherValueContext.Read(&ztype.BitFieldArrayTraits[int8]{NumBits: uint8(8)}, r); err == nil {
			v.OtherValue = (int8)(tempValue)
		} else {
			return err
		}
	}

	if v.Parameter == 7 {
		ztype.AlignReader(r, 16)

		if err = v.EnumValue.UnmarshalZserioPacked(childrenNodes[2], r); err != nil {
			return err
		}
	}

	ztype.AlignReader(r, 8)

	if tempValue, err := ztype.ReadString(r); err == nil {
		v.Description = (string)(tempValue)
	} else {
		return err
	}
	_ = err // to avoid "declared but not used" warning
	return nil
}

func (v *ValueWrapper) MarshalZserioPacked(contextNode *zserio.PackingContextNode, w *bitio.CountWriter) error {
	var err error
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldValueContext, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		if err := fieldValueContext.Write(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, w, int32(v.Value)); err != nil {
			return err
		}
	}

	if fieldOtherValueContext, ok := childrenNodes[1].Context.(*ztype.DeltaContext[int8]); !ok {
		return errors.New("unknown context type")
	} else {
		if err := fieldOtherValueContext.Write(&ztype.BitFieldArrayTraits[int8]{NumBits: uint8(8)}, w, int8(v.OtherValue)); err != nil {
			return err
		}
	}

	if v.Parameter == 7 {
		if err := ztype.AlignWriter(w, 16); err != nil {
			return err
		}
		if err := v.EnumValue.MarshalZserioPacked(childrenNodes[2], w); err != nil {
			return err
		}
	}

	if err := ztype.AlignWriter(w, 8); err != nil {
		return err
	}
	if err := ztype.WriteString(w, v.Description); err != nil {
		return err
	}
	_ = err // to avoid "declared but not used" warning
	return nil
}

func (v *ValueWrapper) ZserioInitializeOffsetsPacked(contextNode *zserio.PackingContextNode, bitPosition int) int {
	return 0
}

func (v *ValueWrapper) ZserioBitSizePacked(contextNode *zserio.PackingContextNode, bitPosition int) (int, error) {
	endBitPosition := bitPosition
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldValueContext, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return 0, errors.New("invalid packing context")
	} else {
		if delta, err := fieldValueContext.BitSizeOf(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, endBitPosition, int32(v.Value)); err != nil {
			return 0, err
		} else {
			endBitPosition += delta
		}
	}

	if fieldOtherValueContext, ok := childrenNodes[1].Context.(*ztype.DeltaContext[int8]); !ok {
		return 0, errors.New("invalid packing context")
	} else {
		if delta, err := fieldOtherValueContext.BitSizeOf(&ztype.BitFieldArrayTraits[int8]{NumBits: uint8(8)}, endBitPosition, int8(v.OtherValue)); err != nil {
			return 0, err
		} else {
			endBitPosition += delta
		}
	}

	endBitPosition += ztype.CountAlignBits(endBitPosition, 16)
	if delta, err := v.EnumValue.ZserioBitSizePacked(childrenNodes[2], endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}

	endBitPosition += ztype.CountAlignBits(endBitPosition, 8)

	if delta, err := ztype.BitSizeOfString(v.Description); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}
	return endBitPosition - bitPosition, nil
}

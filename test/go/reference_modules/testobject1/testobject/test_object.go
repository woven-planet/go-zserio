// Code generated by go-zserio. DO NOT EDIT.

package testobject

import (
	"errors"
	"github.com/icza/bitio"
	zserio "github.com/woven-planet/go-zserio/interface"
	reference_modules_core_instantiations "github.com/woven-planet/go-zserio/test/go/reference_modules/core/instantiations"
	reference_modules_core_types "github.com/woven-planet/go-zserio/test/go/reference_modules/core/types"
	"github.com/woven-planet/go-zserio/ztype"
)

type TestObject struct {
	Parameter1   int32
	Struct1      reference_modules_core_instantiations.InstantiatedTemplateStruct
	Color1       reference_modules_core_types.Color
	Parameter2   int32
	StructArray  ztype.Array[*reference_modules_core_instantiations.InstantiatedTemplateStruct, ztype.ObjectArrayTraits[*reference_modules_core_instantiations.InstantiatedTemplateStruct]]
	BitmaskArray ztype.Array[*reference_modules_core_types.CityAttributes, ztype.ObjectArrayTraits[*reference_modules_core_types.CityAttributes]]
}

func (v *TestObject) Clone() zserio.ZserioType {
	clone := &TestObject{}
	*clone = *v
	return clone
}

func (v *TestObject) LoadDefaultValues() error {

	if err := v.Struct1.LoadDefaultValues(); err != nil {
		return err
	}

	if err := v.Color1.LoadDefaultValues(); err != nil {
		return err
	}

	return nil
}

// MarshalZserio implements the zserio.Marshaler interface.
func (v *TestObject) MarshalZserio(w *bitio.CountWriter) error {
	var err error

	if err = ztype.WriteInt32(w, v.Parameter1); err != nil {
		return err
	}

	v.Struct1.Parameter = int32(v.Parameter1)
	if err = v.Struct1.MarshalZserio(w); err != nil {
		return err
	}

	if err = v.Color1.MarshalZserio(w); err != nil {
		return err
	}

	if err := ztype.AlignWriter(w, 8); err != nil {
		return err
	}
	if err = ztype.WriteInt32(w, v.Parameter2); err != nil {
		return err
	}

	for _, arrayElement := range v.StructArray.RawArray {
		arrayElement.Parameter = int32(v.Parameter2)
	}

	v.StructArray.ArrayTraits = ztype.ObjectArrayTraits[*reference_modules_core_instantiations.InstantiatedTemplateStruct]{}
	v.StructArray.IsPacked = true
	v.StructArray.IsAuto = true
	if err = v.StructArray.MarshalZserio(w); err != nil {
		return err
	}

	if err := ztype.AlignWriter(w, 5); err != nil {
		return err
	}

	v.BitmaskArray.ArrayTraits = ztype.ObjectArrayTraits[*reference_modules_core_types.CityAttributes]{}
	if v.BitmaskArray.Size() != int(100) {
		return errors.New("array size does not match!")
	}
	if err = v.BitmaskArray.MarshalZserio(w); err != nil {
		return err
	}
	_ = err // to avoid "declared but not used" warning
	return nil
}

// UnmarshalZserio implements the zserio.Unmarshaler interface.
func (v *TestObject) UnmarshalZserio(r *bitio.CountReader) error {
	var err error

	if tempValue, err := ztype.ReadInt32(r); err == nil {
		v.Parameter1 = (int32)(tempValue)
	} else {
		return err
	}

	v.Struct1.Parameter = int32(v.Parameter1)
	if err = v.Struct1.UnmarshalZserio(r); err != nil {
		return err
	}

	if err = v.Color1.UnmarshalZserio(r); err != nil {
		return err
	}

	ztype.AlignReader(r, 8)
	if tempValue, err := ztype.ReadInt32(r); err == nil {
		v.Parameter2 = (int32)(tempValue)
	} else {
		return err
	}

	v.StructArray.ArrayTraits = ztype.ObjectArrayTraits[*reference_modules_core_instantiations.InstantiatedTemplateStruct]{}
	v.StructArray.IsPacked = true
	v.StructArray.IsAuto = true
	v.StructArray.ArrayTraits.DefaultObject = new(reference_modules_core_instantiations.InstantiatedTemplateStruct)

	v.StructArray.ArrayTraits.DefaultObject.Parameter = int32(v.Parameter2)
	if err = v.StructArray.UnmarshalZserio(r); err != nil {
		return err
	}

	ztype.AlignReader(r, 5)

	v.BitmaskArray.ArrayTraits = ztype.ObjectArrayTraits[*reference_modules_core_types.CityAttributes]{}
	v.BitmaskArray.FixedSize = int(100)
	v.BitmaskArray.ArrayTraits.DefaultObject = new(reference_modules_core_types.CityAttributes)

	if err = v.BitmaskArray.UnmarshalZserio(r); err != nil {
		return err
	}
	_ = err // to avoid "declared but not used" warning
	return nil
}

// ZserioBitSize implements the zserio.Marshaler interface.
func (v *TestObject) ZserioBitSize(bitPosition int) (int, error) {
	endBitPosition := bitPosition
	endBitPosition += 32

	if delta, err := v.Struct1.ZserioBitSize(endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}

	if delta, err := v.Color1.ZserioBitSize(endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}
	endBitPosition += ztype.CountAlignBits(endBitPosition, 8)
	endBitPosition += 32

	if delta, err := v.StructArray.ZserioBitSize(endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}
	endBitPosition += ztype.CountAlignBits(endBitPosition, 5)

	if delta, err := v.BitmaskArray.ZserioBitSize(endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}
	return endBitPosition - bitPosition, nil
}

func (v *TestObject) ZserioCreatePackingContext(contextNode *zserio.PackingContextNode) error {

	fieldParameter1Node := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldParameter1Node)
	// The field is not a marshalable type, therefore create use a delta context.
	fieldParameter1Node.Context = &ztype.DeltaContext[int32]{}

	fieldStruct1Node := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldStruct1Node)
	var fieldStruct1Ptr *reference_modules_core_instantiations.InstantiatedTemplateStruct
	if err := fieldStruct1Ptr.ZserioCreatePackingContext(fieldStruct1Node); err != nil {
		return err
	}

	fieldColor1Node := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldColor1Node)
	var fieldColor1Ptr *reference_modules_core_types.Color
	if err := fieldColor1Ptr.ZserioCreatePackingContext(fieldColor1Node); err != nil {
		return err
	}

	fieldParameter2Node := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldParameter2Node)
	// The field is not a marshalable type, therefore create use a delta context.
	fieldParameter2Node.Context = &ztype.DeltaContext[int32]{}

	fieldStructArrayNode := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldStructArrayNode)

	fieldBitmaskArrayNode := &zserio.PackingContextNode{}
	contextNode.AddChild(fieldBitmaskArrayNode)

	return nil
}

func (v *TestObject) ZserioInitPackingContext(contextNode *zserio.PackingContextNode) error {
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldParameter1Context, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		fieldParameter1Context.Init(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, int32(v.Parameter1))
	}

	v.Struct1.Parameter = int32(v.Parameter1)
	if err := v.Struct1.ZserioInitPackingContext(childrenNodes[1]); err != nil {
		return err
	}

	if err := v.Color1.ZserioInitPackingContext(childrenNodes[2]); err != nil {
		return err
	}

	if fieldParameter2Context, ok := childrenNodes[3].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		fieldParameter2Context.Init(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, int32(v.Parameter2))
	}

	return nil
}

func (v *TestObject) UnmarshalZserioPacked(contextNode *zserio.PackingContextNode, r *bitio.CountReader) error {
	var err error
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldParameter1Context, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		if tempValue, err := fieldParameter1Context.Read(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, r); err == nil {
			v.Parameter1 = (int32)(tempValue)
		} else {
			return err
		}
	}

	v.Struct1.Parameter = int32(v.Parameter1)
	if err = v.Struct1.UnmarshalZserioPacked(childrenNodes[1], r); err != nil {
		return err
	}

	if err = v.Color1.UnmarshalZserioPacked(childrenNodes[2], r); err != nil {
		return err
	}

	ztype.AlignReader(r, 8)

	if fieldParameter2Context, ok := childrenNodes[3].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		if tempValue, err := fieldParameter2Context.Read(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, r); err == nil {
			v.Parameter2 = (int32)(tempValue)
		} else {
			return err
		}
	}

	v.StructArray.ArrayTraits = ztype.ObjectArrayTraits[*reference_modules_core_instantiations.InstantiatedTemplateStruct]{}
	v.StructArray.IsPacked = true
	v.StructArray.IsAuto = true
	v.StructArray.ArrayTraits.DefaultObject = new(reference_modules_core_instantiations.InstantiatedTemplateStruct)

	v.StructArray.ArrayTraits.DefaultObject.Parameter = int32(v.Parameter2)
	if err = v.StructArray.UnmarshalZserio(r); err != nil {
		return err
	}

	ztype.AlignReader(r, 5)

	v.BitmaskArray.ArrayTraits = ztype.ObjectArrayTraits[*reference_modules_core_types.CityAttributes]{}
	v.BitmaskArray.FixedSize = int(100)
	v.BitmaskArray.ArrayTraits.DefaultObject = new(reference_modules_core_types.CityAttributes)

	// This array is implicitly packed, because its parent object is packed
	v.BitmaskArray.IsPacked = true
	if err = v.BitmaskArray.UnmarshalZserio(r); err != nil {
		return err
	}
	_ = err // to avoid "declared but not used" warning
	return nil
}

func (v *TestObject) MarshalZserioPacked(contextNode *zserio.PackingContextNode, w *bitio.CountWriter) error {
	var err error
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldParameter1Context, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		if err := fieldParameter1Context.Write(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, w, int32(v.Parameter1)); err != nil {
			return err
		}
	}

	v.Struct1.Parameter = int32(v.Parameter1)
	if err := v.Struct1.MarshalZserioPacked(childrenNodes[1], w); err != nil {
		return err
	}

	if err := v.Color1.MarshalZserioPacked(childrenNodes[2], w); err != nil {
		return err
	}

	if err := ztype.AlignWriter(w, 8); err != nil {
		return err
	}
	if fieldParameter2Context, ok := childrenNodes[3].Context.(*ztype.DeltaContext[int32]); !ok {
		return errors.New("unknown context type")
	} else {
		if err := fieldParameter2Context.Write(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, w, int32(v.Parameter2)); err != nil {
			return err
		}
	}

	v.StructArray.ArrayTraits = ztype.ObjectArrayTraits[*reference_modules_core_instantiations.InstantiatedTemplateStruct]{}
	v.StructArray.IsPacked = true
	v.StructArray.IsAuto = true
	for _, arrayElement := range v.StructArray.RawArray {
		arrayElement.Parameter = int32(v.Parameter2)
	}
	if err = v.StructArray.MarshalZserio(w); err != nil {
		return err
	}

	if err := ztype.AlignWriter(w, 5); err != nil {
		return err
	}

	v.BitmaskArray.ArrayTraits = ztype.ObjectArrayTraits[*reference_modules_core_types.CityAttributes]{}
	if v.BitmaskArray.Size() != int(100) {
		return errors.New("array size does not match!")
	}
	// This array is implicitly packed, because its parent object is packed
	v.BitmaskArray.IsPacked = true
	if err = v.BitmaskArray.MarshalZserio(w); err != nil {
		return err
	}
	_ = err // to avoid "declared but not used" warning
	return nil
}

func (v *TestObject) ZserioInitializeOffsetsPacked(contextNode *zserio.PackingContextNode, bitPosition int) int {
	return 0
}

func (v *TestObject) ZserioBitSizePacked(contextNode *zserio.PackingContextNode, bitPosition int) (int, error) {
	endBitPosition := bitPosition
	childrenNodes := contextNode.GetChildren()
	_ = childrenNodes // to avoid "declared but not used" warning

	if fieldParameter1Context, ok := childrenNodes[0].Context.(*ztype.DeltaContext[int32]); !ok {
		return 0, errors.New("invalid packing context")
	} else {
		if delta, err := fieldParameter1Context.BitSizeOf(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, endBitPosition, int32(v.Parameter1)); err != nil {
			return 0, err
		} else {
			endBitPosition += delta
		}
	}

	if delta, err := v.Struct1.ZserioBitSizePacked(childrenNodes[1], endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}

	if delta, err := v.Color1.ZserioBitSizePacked(childrenNodes[2], endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}

	endBitPosition += ztype.CountAlignBits(endBitPosition, 8)
	if fieldParameter2Context, ok := childrenNodes[3].Context.(*ztype.DeltaContext[int32]); !ok {
		return 0, errors.New("invalid packing context")
	} else {
		if delta, err := fieldParameter2Context.BitSizeOf(&ztype.BitFieldArrayTraits[int32]{NumBits: uint8(32)}, endBitPosition, int32(v.Parameter2)); err != nil {
			return 0, err
		} else {
			endBitPosition += delta
		}
	}

	if delta, err := v.StructArray.ZserioBitSizePacked(endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}

	endBitPosition += ztype.CountAlignBits(endBitPosition, 5)
	if delta, err := v.BitmaskArray.ZserioBitSizePacked(endBitPosition); err != nil {
		return 0, err
	} else {
		endBitPosition += delta
	}
	return endBitPosition - bitPosition, nil
}
